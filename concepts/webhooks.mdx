---
title: Webhooks
description: "Receive real-time notifications for Rotavision events"
---

## Overview

Webhooks allow you to receive HTTP callbacks when events occur in your Rotavision account. Instead of polling for status updates, webhooks push data to your server in real-time.

## Supported Events

| Event | Description |
|-------|-------------|
| `analysis.completed` | Fairness analysis job finished |
| `analysis.failed` | Fairness analysis job failed |
| `alert.triggered` | Guardian alert threshold exceeded |
| `alert.resolved` | Guardian alert returned to normal |
| `extraction.completed` | Document extraction finished |
| `extraction.failed` | Document extraction failed |
| `workflow.completed` | Orchestrate workflow finished |
| `workflow.failed` | Orchestrate workflow failed |

## Setting Up Webhooks

### Via Dashboard

1. Go to **Settings → Webhooks** in your dashboard
2. Click **Add Endpoint**
3. Enter your endpoint URL
4. Select events to subscribe to
5. Save and note your signing secret

### Via API

```bash
curl -X POST https://api.rotavision.com/v1/webhooks \
  -H "Authorization: Bearer rv_live_..." \
  -H "Content-Type: application/json" \
  -d '{
    "url": "https://your-app.com/webhooks/rotavision",
    "events": ["analysis.completed", "alert.triggered"],
    "description": "Production webhook"
  }'
```

Response:

```json
{
  "id": "wh_abc123",
  "url": "https://your-app.com/webhooks/rotavision",
  "events": ["analysis.completed", "alert.triggered"],
  "secret": "whsec_xyz789...",
  "status": "active",
  "created_at": "2026-02-01T10:00:00Z"
}
```

<Warning>
  Store your webhook secret securely. You'll need it to verify incoming webhooks.
</Warning>

## Webhook Payload

All webhooks follow this structure:

```json
{
  "id": "evt_abc123",
  "type": "analysis.completed",
  "created_at": "2026-02-01T10:30:00Z",
  "data": {
    "id": "analysis_xyz789",
    "model_id": "loan-approval-v2",
    "overall_score": 0.82,
    "status": "completed"
  }
}
```

## Verifying Signatures

All webhooks are signed using HMAC-SHA256. Verify the signature to ensure the webhook came from Rotavision:

<CodeGroup>

```python Python
import hmac
import hashlib

def verify_webhook(payload: bytes, signature: str, secret: str) -> bool:
    expected = hmac.new(
        secret.encode(),
        payload,
        hashlib.sha256
    ).hexdigest()

    return hmac.compare_digest(f"sha256={expected}", signature)

# In your webhook handler
@app.post("/webhooks/rotavision")
def handle_webhook(request):
    payload = request.body
    signature = request.headers.get("X-Rotavision-Signature")

    if not verify_webhook(payload, signature, WEBHOOK_SECRET):
        return Response(status=401)

    event = json.loads(payload)
    # Process event...
```

```typescript Node.js
import crypto from 'crypto';

function verifyWebhook(
  payload: string,
  signature: string,
  secret: string
): boolean {
  const expected = crypto
    .createHmac('sha256', secret)
    .update(payload)
    .digest('hex');

  return crypto.timingSafeEqual(
    Buffer.from(`sha256=${expected}`),
    Buffer.from(signature)
  );
}

// In your webhook handler (Express)
app.post('/webhooks/rotavision', (req, res) => {
  const payload = req.rawBody;
  const signature = req.headers['x-rotavision-signature'];

  if (!verifyWebhook(payload, signature, WEBHOOK_SECRET)) {
    return res.status(401).send('Invalid signature');
  }

  const event = JSON.parse(payload);
  // Process event...
});
```

```java Java
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.security.MessageDigest;

public boolean verifyWebhook(String payload, String signature, String secret) {
    try {
        Mac mac = Mac.getInstance("HmacSHA256");
        mac.init(new SecretKeySpec(secret.getBytes(), "HmacSHA256"));
        byte[] hash = mac.doFinal(payload.getBytes());
        String expected = "sha256=" + bytesToHex(hash);
        return MessageDigest.isEqual(expected.getBytes(), signature.getBytes());
    } catch (Exception e) {
        return false;
    }
}
```

</CodeGroup>

## Handling Webhooks

### Best Practices

<AccordionGroup>
  <Accordion title="Respond quickly" icon="bolt">
    Return a `200` response within 5 seconds. Process the event asynchronously if needed.

    ```python
    @app.post("/webhooks/rotavision")
    def handle_webhook(request):
        # Verify and enqueue
        event = verify_and_parse(request)
        queue.enqueue(process_event, event)
        return Response(status=200)  # Respond immediately
    ```
  </Accordion>

  <Accordion title="Handle duplicates" icon="clone">
    Webhooks may be delivered multiple times. Use the `id` field for idempotency.

    ```python
    def process_event(event):
        if redis.sismember("processed_events", event["id"]):
            return  # Already processed

        # Process event...

        redis.sadd("processed_events", event["id"])
        redis.expire("processed_events", 86400)  # 24 hour TTL
    ```
  </Accordion>

  <Accordion title="Verify signatures" icon="shield">
    Always verify the `X-Rotavision-Signature` header before processing.
  </Accordion>

  <Accordion title="Handle failures gracefully" icon="rotate">
    If processing fails, return a non-2xx status. We'll retry with exponential backoff.
  </Accordion>
</AccordionGroup>

### Retry Policy

Failed webhook deliveries are retried with exponential backoff:

| Attempt | Delay |
|---------|-------|
| 1 | Immediate |
| 2 | 1 minute |
| 3 | 5 minutes |
| 4 | 30 minutes |
| 5 | 2 hours |
| 6 | 8 hours |
| 7 | 24 hours |

After 7 failed attempts, the webhook is marked as failed and you'll receive an email notification.

## Testing Webhooks

### Using the CLI

```bash
rotavision webhooks trigger analysis.completed \
  --endpoint wh_abc123 \
  --data '{"model_id": "test-model"}'
```

### Using the Dashboard

1. Go to **Settings → Webhooks**
2. Click on your endpoint
3. Click **Send Test Event**
4. Select an event type
5. Review the delivery log

## Event Reference

### analysis.completed

```json
{
  "id": "evt_abc123",
  "type": "analysis.completed",
  "created_at": "2026-02-01T10:30:00Z",
  "data": {
    "id": "analysis_xyz789",
    "model_id": "loan-approval-v2",
    "overall_score": 0.82,
    "bias_detected": true,
    "metrics_summary": {
      "demographic_parity": 0.78,
      "equalized_odds": 0.91,
      "calibration": 0.85
    },
    "report_url": "https://dashboard.rotavision.com/reports/analysis_xyz789"
  }
}
```

### alert.triggered

```json
{
  "id": "evt_def456",
  "type": "alert.triggered",
  "created_at": "2026-02-01T10:30:00Z",
  "data": {
    "id": "alert_uvw123",
    "monitor_id": "mon_abc789",
    "model_id": "recommendation-v3",
    "metric": "prediction_drift",
    "value": 0.25,
    "threshold": 0.1,
    "severity": "high",
    "message": "Significant prediction drift detected (PSI: 0.25)"
  }
}
```

### extraction.completed

```json
{
  "id": "evt_ghi789",
  "type": "extraction.completed",
  "created_at": "2026-02-01T10:30:00Z",
  "data": {
    "id": "extract_mno456",
    "document_type": "aadhaar",
    "confidence": 0.97,
    "fields": {
      "name": "राहुल शर्मा",
      "name_english": "Rahul Sharma",
      "dob": "1990-05-15",
      "gender": "Male",
      "aadhaar_number": "XXXX-XXXX-1234"
    }
  }
}
```
